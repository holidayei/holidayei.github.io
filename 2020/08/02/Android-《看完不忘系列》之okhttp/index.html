<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android," />










<meta name="description" content="嗨，我是哈利迪~《看完不忘系列》将以从树干到细枝的思路分析一些技术框架，本文将对开源项目okhttp网络库进行介绍。  本文约3800字，阅读大约10分钟。如个别大图模糊，可前往个人站点阅读。  概览 源码基于3.14.9，即java版本的最新版  首先上职责图，各个类的名字基本可以见名知意了，就不翻译了，直接起飞~  树干我们先看一趟飞行的大体流程，  好了，进入代码环节，引入依赖， 1impl">
<meta property="og:type" content="article">
<meta property="og:title" content="Android |《看完不忘系列》之okhttp">
<meta property="og:url" content="https://github.com/holidayei/2020/08/02/Android-%E3%80%8A%E7%9C%8B%E5%AE%8C%E4%B8%8D%E5%BF%98%E7%B3%BB%E5%88%97%E3%80%8B%E4%B9%8Bokhttp/index.html">
<meta property="og:site_name" content="Holiday">
<meta property="og:description" content="嗨，我是哈利迪~《看完不忘系列》将以从树干到细枝的思路分析一些技术框架，本文将对开源项目okhttp网络库进行介绍。  本文约3800字，阅读大约10分钟。如个别大图模糊，可前往个人站点阅读。  概览 源码基于3.14.9，即java版本的最新版  首先上职责图，各个类的名字基本可以见名知意了，就不翻译了，直接起飞~  树干我们先看一趟飞行的大体流程，  好了，进入代码环节，引入依赖， 1impl">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbbmhed3mj314807yq4v.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbc45yq1aj317k0mkacr.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcdsro2vdj31940b4jtr.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbgbi291zj30is0ieq45.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcgytdgkpj30zo09y0uk.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcek5exs9j318y0d4gok.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3mnwsbshj308c0augmm.jpg">
<meta property="article:published_time" content="2020-08-02T12:52:35.000Z">
<meta property="article:modified_time" content="2020-08-02T12:53:17.647Z">
<meta property="article:author" content="哈利迪">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbbmhed3mj314807yq4v.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/holidayei/2020/08/02/Android-《看完不忘系列》之okhttp/"/>





  <title>Android |《看完不忘系列》之okhttp | Holiday</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Holiday</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/holidayei/2020/08/02/Android-%E3%80%8A%E7%9C%8B%E5%AE%8C%E4%B8%8D%E5%BF%98%E7%B3%BB%E5%88%97%E3%80%8B%E4%B9%8Bokhttp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="哈利迪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Holiday">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android |《看完不忘系列》之okhttp</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-02T20:52:35+08:00">
                2020-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>嗨，我是哈利迪~《看完不忘系列》将以<code>从树干到细枝</code>的思路分析一些技术框架，本文将对开源项目<code>okhttp</code>网络库进行介绍。</p>
<blockquote>
<p>本文约3800字，阅读大约10分钟。如个别大图模糊，可前往<a href="https://imholiday.cn/" target="_blank" rel="noopener">个人站点</a>阅读。</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><blockquote>
<p>源码基于3.14.9，即java版本的最新版</p>
</blockquote>
<p>首先上职责图，各个类的名字基本可以见名知意了，就不翻译了，直接起飞~</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbbmhed3mj314807yq4v.jpg" alt=""></p>
<h2 id="树干"><a href="#树干" class="headerlink" title="树干"></a>树干</h2><p>我们先看一趟飞行的大体流程，</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbc45yq1aj317k0mkacr.jpg" alt=""></p>
<p>好了，进入代码环节，引入依赖，</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.okhttp3:okhttp:3.14.9'</span></span><br></pre></td></tr></table></figure>

<p>简单使用（只分析异步请求，同步请求类似），</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OkhttpActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建机场，通常是单例</span></span><br><span class="line">    OkHttpClient mClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        String url = <span class="string">"xxx"</span>;</span><br><span class="line">        <span class="comment">//构建者模式创建Request请求，设置url（飞去哪里）</span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">        <span class="comment">//知道目的地后，创建Call会话（本次航班）</span></span><br><span class="line">        Call call = mClient.newCall(request);</span><br><span class="line">        <span class="comment">//异步请求入队（飞机进入就绪跑道）</span></span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//本次航班失败 - -</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//抵达目的地！</span></span><br><span class="line">                <span class="comment">//body只能取一次，Response就会关闭，所以要用临时变量接收</span></span><br><span class="line">                String result = response.body().string();</span><br><span class="line">                <span class="comment">//回调在子线程，要操作UI的话需切回主线程</span></span><br><span class="line">                runOnUiThread(() -&gt; &#123;</span><br><span class="line">                    mBinding.tv.setText(result);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>OkHttpClient</code>和<code>Request</code>使用构建者模式创建即可，当然，如果<code>OkHttpClient</code>不需要进行配置，直接new就行。知道了起点和终点，就可以创建航班<code>Call</code>了，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttpClient.java</span></span><br><span class="line"><span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function">RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    <span class="comment">//Transmitter意为发射器，功能挺杂的，就先叫他机长吧</span></span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见<code>Call</code>的实例是<code>RealCall</code>，航班创建好后，进入就绪跑道，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//机长回调eventListener，实时汇报航班状态，先忽略</span></span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="comment">//用AsyncCall封装Callback，由机场调度中心dispatcher安排进入就绪跑道</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AsyncCall</code>就是一个Runnable，run方法里调了execute方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AsyncCall.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到Response，抵达目的地</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="comment">//成功（一般response.isSuccessful()才是真正意义上的成功）</span></span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//失败</span></span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancel();</span><br><span class="line">        IOException canceledException = <span class="keyword">new</span> IOException(<span class="string">"canceled due to "</span> + t);</span><br><span class="line">        canceledException.addSuppressed(t);</span><br><span class="line">        <span class="comment">//失败</span></span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, canceledException);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//结束航班，callsPerHost减1，runningAsyncCalls移除AsyncCall</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AsyncCall</code>里有一个原子计数器，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目前每个主机（域名）有多少个会话call</span></span><br><span class="line"><span class="keyword">volatile</span> AtomicInteger callsPerHost = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>Dispatcher</code>里有两个默认max值，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxRequests = <span class="number">64</span>;  <span class="comment">//最多同时请求数为64</span></span><br><span class="line"><span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;  <span class="comment">//每个主机最多同时请求数为5</span></span><br></pre></td></tr></table></figure>

<p>什么意思呢？可以这么理解，机场的调度中心，限制了同时最多起飞的航班为64班；飞往同一个城市的航班，同时最多只能有5班，为什么做城市限制？跟连接池的复用有关，后面会讲。下面我们以上海为例，</p>
<p>看下enqueue方法做了啥，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line">enqueue(AsyncCall call) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//飞机进入就绪跑道</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">            <span class="comment">//查找飞往上海的AsyncCall</span></span><br><span class="line">            AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">            <span class="comment">//复用上海的计数器callsPerHost，用于统计同一城市的航班</span></span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//飞机进入起飞跑道</span></span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进promoteAndExecute，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//收集可以执行的AsyncCall</span></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            AsyncCall asyncCall = i.next();</span><br><span class="line">			<span class="comment">//64个起飞跑道被占满，跳出</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//飞往上海的航班达到5个，留在就绪跑道就行，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//离开就绪跑道</span></span><br><span class="line">            i.remove();</span><br><span class="line">            <span class="comment">//上海航班计数器+1</span></span><br><span class="line">            asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">            <span class="comment">//把AsyncCall存起来</span></span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            <span class="comment">//进入起飞跑道</span></span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//把可以执行的AsyncCall，统统起飞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">        asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中executorService()返回了一个线程池，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executorService =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, </span><br><span class="line">                                   <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), </span><br><span class="line">                                   Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数为0，空闲了60秒后，所有线程会被清空；最大线程数无限制，其实还好，已经有调度中心<code>Dispatcher</code>会限制请求数了。</p>
<p>继续跟进executeOn方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AsyncCall.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//线程池运行Runnable，执行run，调用前面提到的AsyncCall.execute</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        transmitter.noMoreExchanges(ioException);</span><br><span class="line">        <span class="comment">//失败回调</span></span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">//结束航班</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，回调都在子线程里完成，所以Activity里要切回主线程才能操作UI。至此，核心流程就结束了。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcdsro2vdj31940b4jtr.jpg" alt=""></p>
<h2 id="细枝"><a href="#细枝" class="headerlink" title="细枝"></a>细枝</h2><h3 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h3><p>前边得到<code>Response</code>的地方，调了getResponseWithInterceptorChain，进去看看，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加自定义拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//添加默认拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        <span class="comment">//添加自定义网络拦截器（在ConnectInterceptor后面，此时网络连接已准备好）</span></span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加默认拦截器，共4+1=5个</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">    <span class="comment">//创建拦截器链</span></span><br><span class="line">    Interceptor.Chain chain =</span><br><span class="line">        <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">                                 originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">                                 client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">    <span class="comment">//放行</span></span><br><span class="line">    Response response = chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器链基于<code>责任链模式</code>，即不同的拦截器有不同的职责，链上的拦截器会按顺序挨个处理，在<code>Request</code>发出之前，<code>Response</code>返回之前，插入一些定制逻辑，这样可以方便的扩展需求。当然<code>责任链模式</code>也有不足，就是只要一个环节阻塞住了，就会拖慢整体运行（效率）；同时链条越长，产生的中间对象就越多（内存）。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbgbi291zj30is0ieq45.jpg" alt=""></p>
<p>我们先跟proceed方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealInterceptorChain.java</span></span><br><span class="line"><span class="function">Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter,Exchange exchange)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//传入index + 1，可以访问下一个拦截器</span></span><br><span class="line">    RealInterceptorChain next = </span><br><span class="line">        <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">                                 index + <span class="number">1</span>, request, call, connectTimeout, </span><br><span class="line">                                 readTimeout, writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">//执行第一个拦截器，同时传入next</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    <span class="comment">//等所有拦截器处理完，就能返回Response了</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面简要分析下各个拦截器的功能。</p>
<p>一、<code>RetryAndFollowUpInterceptor</code>：</p>
<p>负责重试和重定向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FOLLOW_UPS = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//机长为Request准备一个连接</span></span><br><span class="line">        <span class="comment">//主机、端口、协议都相同时，连接可复用</span></span><br><span class="line">        transmitter.prepareToConnect(request);</span><br><span class="line">        <span class="comment">//放行，让后面的拦截器执行</span></span><br><span class="line">        Response response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//后面的拦截器执行完了，拿到Response，解析看下是否需要重试或重定向，需要则返回新的Request</span></span><br><span class="line">        Request followUp = followUpRequest(response, route);</span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//新的Request为空，直接返回response</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        RequestBody followUpBody = followUp.body();</span><br><span class="line">        <span class="keyword">if</span> (followUpBody != <span class="keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">            <span class="comment">//如果RequestBody有值且只许被调用一次，直接返回response</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            <span class="comment">//重试次数上限，结束</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新的请求赋值给request，继续循环</span></span><br><span class="line">        request = followUp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中followUpRequest方法会根据<code>Response</code>不同的响应码做相应的处理，就不跟了。</p>
<p>二、<code>BridgeInterceptor</code>：</p>
<p>桥接，负责把应用请求转换成网络请求，把网络响应转换成应用响应，说白了就是处理一些网络需要的header，简化应用层逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">        <span class="comment">//处理Content-Length、Transfer-Encoding</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理Host、Connection、Accept-Encoding、Cookie、User-Agent、</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//放行，把处理好的新请求往下传递，得到Response</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line">	<span class="comment">//处理新Response的Content-Encoding、Content-Length、Content-Type、gzip</span></span><br><span class="line">    <span class="comment">//返回新Response</span></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的一点是，在服务器支持gzip压缩的前提下，客户端不设置Accept-Encoding=gzip的话，<code>okhttp</code>会自动帮我们开启gzip和解压数据，如果客户端自己开启了gzip，就需要自己解压服务器返回的数据了。</p>
<p>三、<code>CacheInterceptor</code>：</p>
<p>负责管理缓存，使用okio读写缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">InternalCache cache;</span><br><span class="line"></span><br><span class="line"><span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取候选缓存</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//创建缓存策略</span></span><br><span class="line">    CacheStrategy strategy = </span><br><span class="line">        <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    <span class="comment">//网络请求</span></span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    <span class="comment">//缓存Response</span></span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">    <span class="comment">//如果网络请求和缓存Response都为空</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//返回一个504的Response</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder().code(<span class="number">504</span>).xxx.build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不使用网络，直接返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse)).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放行，往后走</span></span><br><span class="line">    Response networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取到缓存响应码304，即缓存可用</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder().xxx.build();</span><br><span class="line">            <span class="comment">//更新缓存，返回</span></span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取网络Response</span></span><br><span class="line">    Response response = networkResponse.newBuilder().xxx.build();</span><br><span class="line">    <span class="comment">//写入缓存，返回</span></span><br><span class="line">    cache.put(response);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于缓存策略<code>CacheStrategy</code>会在<code>缓存</code>章节展开。</p>
<p>四、<code>ConnectInterceptor</code>：</p>
<p>负责创建连接<code>Connection</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//机长创建一个交换器Exchange</span></span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">//放行，给下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newExchange方法会在<code>连接池</code>章节展开。</p>
<p>五、<code>CallServerInterceptor</code>：</p>
<p> 负责写请求和读响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Exchange exchange = realChain.exchange();</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    <span class="comment">//写请求头</span></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//处理请求体body...</span></span><br><span class="line">    <span class="comment">//读取响应头</span></span><br><span class="line">    responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//构建响应</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//读取响应体</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(exchange.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存的实现是基于请求和响应的header来做的。<code>CacheStrategy</code>即缓存策略，<code>CacheInterceptor</code>拦截器会根据他拿到网络请求networkRequest、缓存响应cacheResponse，从而决定是使用网络还是缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheStrategy.java</span></span><br><span class="line"><span class="comment">//内部类工厂，生产CacheStrategy</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一些字段：servedDate、lastModified、expires、etag...</span></span><br><span class="line">    Factory(<span class="keyword">long</span> nowMillis, Request request, Response cacheResponse) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nowMillis = nowMillis;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line">        <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//解析cacheResponse，把参数赋值给自己的成员变量</span></span><br><span class="line">            <span class="keyword">this</span>.sentRequestMillis = cacheResponse.sentRequestAtMillis();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            Headers headers = cacheResponse.headers();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">                String fieldName = headers.name(i);</span><br><span class="line">                String value = headers.value(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"Date"</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                    servedDate = HttpDate.parse(value);</span><br><span class="line">                    servedDateString = value;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xxx)&#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheStrategy candidate = getCandidate();</span><br><span class="line">        <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">            <span class="comment">//返回策略，交给拦截器</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据header字段，得到各种策略，交给拦截器...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(xxx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getCandidate里面就是根据header字段得到各种策略，然后交给拦截器处理，感兴趣的读者自行阅读啦。</p>
<p>那么缓存是如何写入磁盘的呢？跟进<code>InternalCache</code>接口，他的实现在<code>Cache</code>类里，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cache.java</span></span><br><span class="line">InternalCache internalCache = <span class="keyword">new</span> InternalCache() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Cache.<span class="keyword">this</span>.get(request);<span class="comment">//读取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Cache.<span class="keyword">this</span>.put(response);<span class="comment">//写入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    String key = key(request.url()); <span class="comment">//键</span></span><br><span class="line">    DiskLruCache.Snapshot snapshot; <span class="comment">//缓存快照</span></span><br><span class="line">    Entry entry;</span><br><span class="line">    snapshot = cache.get(key); <span class="comment">//cache是okhttp的DiskLruCache</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没缓存，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快照得到输入流，用于创建缓存条目</span></span><br><span class="line">    entry = <span class="keyword">new</span> Entry(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">    <span class="comment">//得到响应</span></span><br><span class="line">    Response response = entry.response(snapshot);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">    String requestMethod = response.request().method();</span><br><span class="line">    <span class="keyword">if</span> (!requestMethod.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">        <span class="comment">//不是get请求，不缓存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装成日志条目</span></span><br><span class="line">    Entry entry = <span class="keyword">new</span> Entry(response);</span><br><span class="line">    DiskLruCache.Editor editor = <span class="keyword">null</span>;</span><br><span class="line">    editor = cache.edit(key(response.request().url()));</span><br><span class="line">    <span class="comment">//写入缓存</span></span><br><span class="line">    entry.writeTo(editor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>okhttp的<code>DiskLruCache</code>，就是根据最近最少使用算法，来管理磁盘缓存，他和Glide里的<code>DiskLruCache</code>有几份相似，比如日志处理都一样，内部都有一个线程池来清理磁盘，不过okhttp有用到okio。感兴趣的读者可以留意下<code>okhttp3.internal.cache.DiskLruCache</code>和<code>com.bumptech.glide.disklrucache.DiskLruCache</code>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcgytdgkpj30zo09y0uk.jpg" alt=""></p>
<p>注：缓存默认是关闭的，需要自行开启：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .cache(<span class="keyword">new</span> Cache(<span class="keyword">new</span> File(MyApp.APP.getCacheDir(), <span class="string">"okhttp_cache"</span>), <span class="comment">//路径</span></span><br><span class="line">                     <span class="number">50L</span> * <span class="number">1024L</span> * <span class="number">1024L</span>)) <span class="comment">//大小</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>还记得<code>Transmitter</code>吗，前面我们叫他机长，他是应用和网络之间的桥梁，管理着连接、请求、响应和流。在<code>拦截器</code>章节知道：</p>
<p><code>RetryAndFollowUpInterceptor</code>里调了transmitter.prepareToConnect；准备一个连接</p>
<p><code>ConnectInterceptor</code>里调了transmitter.newExchange；创建一个交换器</p>
<p>这里补充几个概念：</p>
<blockquote>
<p>Connection，实现为RealConnection：连接，抽象概念，内部维护了Socket</p>
<p>ConnectionPool，持有RealConnectionPool：连接池，管理连接的复用</p>
<p>Exchange：交换器（管理请求和响应、持有ExchangeCodec）</p>
<p>ExchangeCodec：编解码器，用于编码请求，解码响应，实现有Http1ExchangeCodec和Http2ExchangeCodec</p>
<p>HTTP 1.1：引入keep-alive机制，支持连接保活，可以多个请求复用一个连接，但请求是串行的</p>
<p>HTTP 2.0：支持多路复用，一个连接的多个请求可以并行</p>
</blockquote>
<p>先看<code>RealConnectionPool</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealConnectionPool.java</span></span><br><span class="line"><span class="comment">//线程池，用于清理过期的连接。一个连接池最多运行一个线程</span></span><br><span class="line">Executor executor =</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,<span class="number">60L</span>,TimeUnit.SECONDS,</span><br><span class="line">                           <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), </span><br><span class="line">                           Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</span><br><span class="line"><span class="comment">//每个ip地址的最大空闲连接数，为5个</span></span><br><span class="line"><span class="keyword">int</span> maxIdleConnections;</span><br><span class="line"><span class="comment">//空闲连接存活时间，为5分钟</span></span><br><span class="line"><span class="keyword">long</span> keepAliveDurationNs;</span><br><span class="line"><span class="comment">//连接队列</span></span><br><span class="line">Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           List&lt;Route&gt; routes, <span class="keyword">boolean</span> requireMultiplexed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">        <span class="comment">//要求多路复用，跳过不支持多路复用的连接</span></span><br><span class="line">        <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//不合条件，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//给机长分配一个连接</span></span><br><span class="line">        transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除连接，executor运行cleanupRunnable，调用了该方法</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查找移除的连接，或下一次移除的时间</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">            || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">            <span class="comment">//移除连接</span></span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭Socket</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RealConnection</code>代码有点多，知道他内部维护了Socket就行了。</p>
<p>前面提到过，同一主机的同时请求数被限制成maxRequestsPerHost = 5 ，为什么这么做？同主机的请求可以共用一个连接，所以大概是为了限流？比如同时飞往上海的航班如果不限数量，会把上海机场挤爆？有知道答案的小伙伴留下评论呀~</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>okhhttp</code>具有以下优势：</p>
<ul>
<li>使用简单，拦截器链的设计方便扩展</li>
<li>请求失败能自动重连和尝试主机的其他ip、能重定向</li>
<li>可以自动处理gzip</li>
<li>本地缓存可以避免重复请求</li>
<li>同主机的请求可以共享一个Socket，socket由Connection维护，ConnectionPool管理Connection的复用，避免频繁地创建和销毁连接</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghcek5exs9j318y0d4gok.jpg" alt=""></p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>还是那句话，该系列旨在摸清技术的整体实现思路，<code>okhhttp</code>里还有很多精彩细节，如cookie、route、dns、tls等处理，本文没有提到，大家还是要对着源码学习呀。哈迪在看源码过程还发现了很多不懂的地方，比如各种协议和标准，这也是个补充网络知识的好机会，一起飞~</p>
<p>系列文章：</p>
<ul>
<li><a href="https://juejin.im/post/6850037281349173261" target="_blank" rel="noopener">《看完不忘系列》之Glide</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">官网</a> &amp; <a href="https://github.com/square/okhttp">GitHub</a> &amp; <a href="https://square.github.io/okhttp/3.x/okhttp/" target="_blank" rel="noopener">3.x文档</a></li>
<li><a href="https://juejin.im/post/6844904191123685389" target="_blank" rel="noopener">掘金- 网络请求框架OkHttp3全解系列（四）拦截器详解2</a></li>
</ul>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg3mnwsbshj308c0augmm.jpg" alt=""></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/26/Android-xml%E5%92%8Cview%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/" rel="next" title="Android | xml和view的那些事">
                <i class="fa fa-chevron-left"></i> Android | xml和view的那些事
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/06/%E8%B8%A9%E5%9D%91%E8%AE%B0-Flutter%E5%8D%87%E7%BA%A7%E5%BD%B1%E5%93%8D%E4%BA%86NestedScrollView%EF%BC%9F/" rel="prev" title="踩坑记 | Flutter升级影响了NestedScrollView？">
                踩坑记 | Flutter升级影响了NestedScrollView？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">哈利迪</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">


              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>



            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概览"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树干"><span class="nav-number">2.</span> <span class="nav-text">树干</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#细枝"><span class="nav-number">3.</span> <span class="nav-text">细枝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拦截器链"><span class="nav-number">3.1.</span> <span class="nav-text">拦截器链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">3.2.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接池"><span class="nav-number">3.3.</span> <span class="nav-text">连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">3.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尾声"><span class="nav-number">4.</span> <span class="nav-text">尾声</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">哈利迪</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
